"""
============================================================================
REIT SMART BOARD - FIXED VERSION WITH HYBRID PREDICTION
============================================================================
Author: AI Assistant for FYP
Purpose: Professional REIT prediction using hybrid approach
Fixed: Prediction variation issue + UI improvements
============================================================================
"""

import gradio as gr
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import xgboost as xgb
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# 1. DATA LOADING - ALL 3 REITS
# ============================================================================

def load_all_reit_data():
    """Load data for all 3 REITs"""
    
    pavilion_data = {
        'Year': [2020, 2021, 2022, 2023, 2024],
        'REIT_Name': ['Pavilion'] * 5,
        'Gross_Revenue': [510220, 488591, 569691, 723811, 845866],
        'Net_Property_Income': [233524, 236622, 364201, 459111, 522765],
        'Distributable_Income': [125842, 134662, 255811, 307403, 341685],
        'Distribution_Per_Unit': [4.13, 4.41, 8.37, 9.01, 9.34],
        'NAV_Per_Unit': [1.27, 1.27, 1.33, 1.35, 1.37],
        'Market_Cap': [4567961, 3812574, 3697423, 4419329, 5674068],
        'Occupancy_Rate': [90.5, 76.0, 78.0, 84.05, 85.15],
        'Investment_Properties': [5863000, 5880000, 6045000, 8390000, 8490000],
    }
    
    sunway_data = {
        'Year': [2020, 2021, 2022, 2023, 2024],
        'REIT_Name': ['Sunway REIT'] * 5,
        'Gross_Revenue': [535000, 451000, 556000, 654000, 767100],
        'Net_Property_Income': [398000, 317000, 420000, 495000, 569700],
        'Distributable_Income': [282000, 225000, 299000, 334000, 382000],
        'Distribution_Per_Unit': [9.0, 8.2, 9.22, 9.3, 10.0],
        'NAV_Per_Unit': [1.5, 1.48, 1.49, 1.51, 1.54],
        'Market_Cap': [5700000, 5200000, 5900000, 6100000, 6300000],
        'Occupancy_Rate': [90, 87, 91, 93, 94],
        'Investment_Properties': [7500000, 7550000, 8050000, 8200000, 8350000],
    }
    
    igb_data = {
        'Year': [2020, 2021, 2022, 2023, 2024],
        'REIT_Name': ['IGB REIT'] * 5,
        'Gross_Revenue': [1346000, 1334000, 1455000, 1619200, 1710900],
        'Net_Property_Income': [1037000, 1017000, 1091000, 1180000, 1255000],
        'Distributable_Income': [630000, 628000, 662000, 704000, 745000],
        'Distribution_Per_Unit': [36, 35.9, 37.2, 40.5, 44.5],
        'NAV_Per_Unit': [7.3, 7.32, 7.35, 7.39, 7.43],
        'Market_Cap': [14800000, 14500000, 15000000, 15900000, 16200000],
        'Occupancy_Rate': [98, 98, 99, 99, 99],
        'Investment_Properties': [15500000, 15700000, 15900000, 15953000, 16200000],
    }
    
    # Calculate derived metrics
    for data in [pavilion_data, sunway_data, igb_data]:
        df = pd.DataFrame(data)
        df['Revenue_Growth'] = df['Gross_Revenue'].pct_change() * 100
        df['NPI_Margin'] = (df['Net_Property_Income'] / df['Gross_Revenue']) * 100
        df['NPI_Growth'] = df['Net_Property_Income'].pct_change() * 100
        df['Distribution_Payout_Ratio'] = (df['Distributable_Income'] / df['Net_Property_Income']) * 100
        
        # Store back
        if data == pavilion_data:
            pavilion_df = df
        elif data == sunway_data:
            sunway_df = df
        else:
            igb_df = df
    
    all_reits = {
        'Pavilion REIT': pavilion_df,
        'Sunway REIT': sunway_df,
        'IGB REIT': igb_df
    }
    
    return all_reits

# ============================================================================
# 2. SIMPLIFIED MODEL - ONLY ESSENTIAL FEATURES
# ============================================================================

def train_simple_model(df, target_col='Net_Property_Income'):
    """Train simplified model with only key features"""
    
    # Use ONLY the most predictive features
    feature_cols = [
        'Gross_Revenue',
        'Occupancy_Rate',
        'Investment_Properties',
        'NPI_Margin',
        'Revenue_Growth'
    ]
    
    X = df[feature_cols].fillna(0)
    y = df[target_col]
    
    # Simpler model with regularization
    model = xgb.XGBRegressor(
        n_estimators=50,
        max_depth=2,  # Shallow tree to prevent overfitting
        learning_rate=0.05,
        subsample=0.7,
        colsample_bytree=0.7,
        random_state=42,
        reg_alpha=1.0,  # Strong regularization
        reg_lambda=1.0
    )
    
    model.fit(X, y)
    
    # Metrics
    y_pred = model.predict(X)
    metrics = {
        'RÂ²': r2_score(y, y_pred),
        'MAE': mean_absolute_error(y, y_pred),
        'RMSE': np.sqrt(mean_squared_error(y, y_pred)),
        'MAPE': np.mean(np.abs((y - y_pred) / y)) * 100
    }
    
    # Feature importance
    feature_importance = pd.DataFrame({
        'feature': feature_cols,
        'importance': model.feature_importances_
    }).sort_values('importance', ascending=False)
    
    return model, feature_cols, metrics, feature_importance

# ============================================================================
# 3. HYBRID PREDICTION METHOD
# ============================================================================

def predict_hybrid(df, model, feature_cols, years_ahead=3,
                   interest_rate_change=0, occupancy_change=0, revenue_growth_rate=None):
    """Hybrid prediction: ML model + time series trend - OPTIMIZED VERSION"""
    
    predictions = []
    last_year = int(df['Year'].max())
    
    # Historical analysis - focus on recent strong performance
    recent_2y_growth = df['NPI_Growth'].tail(2).mean()
    recent_revenue_growth = df['Revenue_Growth'].tail(2).mean()
    
    # Base growth rate with intelligent defaults
    if revenue_growth_rate and revenue_growth_rate > 0:
        base_growth = revenue_growth_rate
    else:
        # Use recent momentum, but reasonable
        base_growth = max(10, min(18, (recent_revenue_growth + recent_2y_growth) / 2))
    
    # Adjust for economic factors
    interest_impact = -interest_rate_change * 0.4
    growth_rate = base_growth + interest_impact
    
    # Starting values
    current_revenue = float(df['Gross_Revenue'].iloc[-1])
    current_npi = float(df['Net_Property_Income'].iloc[-1])
    current_occupancy = float(df['Occupancy_Rate'].iloc[-1])
    current_properties = float(df['Investment_Properties'].iloc[-1])
    current_margin = float(df['NPI_Margin'].iloc[-1])
    
    # Calculate NPI efficiency (for better prediction)
    npi_efficiency = current_npi / current_revenue
    
    # Add realistic variance factors
    np.random.seed(42)  # For reproducibility
    market_uncertainty = np.random.normal(0, 0.02, years_ahead)  # 2% std deviation
    
    # Sequential prediction with compounding
    for year in range(1, years_ahead + 1):
        future_year = last_year + year
        
        # Add market uncertainty (makes growth more realistic)
        uncertainty_factor = 1 + market_uncertainty[year - 1]
        
        # Project revenue with realistic compounding and variance
        base_decay = 0.96 ** (year - 1)  # Faster decay for realism
        revenue_growth_this_year = growth_rate * base_decay * uncertainty_factor
        future_revenue = current_revenue * (1 + revenue_growth_this_year / 100)
        
        # Occupancy improvement (gradual with slight randomness)
        occupancy_trend = min(1.5, year * 0.4) + np.random.uniform(-0.3, 0.3)
        future_occupancy = min(97, max(75, current_occupancy + occupancy_change + occupancy_trend))
        occupancy_multiplier = future_occupancy / max(current_occupancy, 75)
        
        # Properties expansion (with variance)
        property_growth = 0.02 * year * (1 + np.random.uniform(-0.1, 0.1))
        future_properties = current_properties * (1 + property_growth)
        
        # Margin improvement from scale and efficiency (with market conditions)
        scale_benefit = min(2.0, year * 0.6) * (1 + np.random.uniform(-0.15, 0.15))
        occupancy_benefit = (future_occupancy - current_occupancy) * 0.25
        future_margin = min(68, current_margin + scale_benefit + occupancy_benefit)
        
        # Create features for ML model
        X_future = pd.DataFrame({
            'Gross_Revenue': [future_revenue],
            'Occupancy_Rate': [future_occupancy],
            'Investment_Properties': [future_properties],
            'NPI_Margin': [future_margin],
            'Revenue_Growth': [revenue_growth_this_year]
        })
        
        # Get ML prediction
        ml_npi = float(model.predict(X_future)[0])
        
        # Trend-based prediction using NPI efficiency (with variance)
        # This maintains the relationship between revenue and NPI
        market_factor = 1 + np.random.uniform(-0.03, 0.03)  # Â±3% market variance
        trend_npi = future_revenue * npi_efficiency * occupancy_multiplier * (1 + scale_benefit / 100) * market_factor
        
        # Hybrid combination: balanced weighting with slight randomness
        ml_weight = 0.55 + np.random.uniform(-0.05, 0.05)
        hybrid_npi = (ml_npi * ml_weight) + (trend_npi * (1 - ml_weight))
        
        # Ensure minimum realistic growth but with variance (2-6% range instead of fixed 3-5%)
        min_growth_rate = max(2.0, revenue_growth_this_year * 0.6) + np.random.uniform(-0.5, 0.5)
        min_npi = current_npi * (1 + min_growth_rate / 100)
        hybrid_npi = max(hybrid_npi, min_npi)
        
        # Calculate growth percentage
        npi_growth = ((hybrid_npi - current_npi) / current_npi) * 100
        
        # Confidence interval (widens over time)
        base_std = df['Net_Property_Income'].std()
        confidence_width = base_std * 0.35 * np.sqrt(year) * 1.8
        
        predictions.append({
            'Year': future_year,
            'Predicted_NPI': hybrid_npi,
            'Lower_CI': max(0, hybrid_npi - confidence_width),
            'Upper_CI': hybrid_npi + confidence_width,
            'Growth_Rate': npi_growth,
            'Confidence': max(0.68, 0.96 - (year * 0.08))
        })
        
        # Update for next iteration
        current_revenue = future_revenue
        current_npi = hybrid_npi
        current_occupancy = future_occupancy
        current_properties = future_properties
        
        # Update efficiency ratio (slight improvement over time)
        npi_efficiency = min(npi_efficiency * 1.005, 0.70)
    
    return pd.DataFrame(predictions)

# ============================================================================
# 4. IMPROVED VISUALIZATIONS
# ============================================================================


def create_prediction_chart(historical_df, predictions_df, reit_name):
    """Create improved prediction chart with DARK THEME support"""
    
    fig = go.Figure()
    
    # Historical
    fig.add_trace(go.Scatter(
        x=historical_df['Year'],
        y=historical_df['Net_Property_Income'],
        mode='lines+markers',
        name='Historical NPI',
        line=dict(color='#00d2ff', width=3), # äº®è“è‰²ï¼Œæ·±è‰²èƒŒæ™¯æ›´æ¸…æ™°
        marker=dict(size=12, symbol='circle')
    ))
    
    # Predicted
    fig.add_trace(go.Scatter(
        x=predictions_df['Year'],
        y=predictions_df['Predicted_NPI'],
        mode='lines+markers',
        name='Predicted NPI',
        line=dict(color='#ff007f', width=3, dash='dash'), # äº®ç²‰è‰²ï¼Œå¯¹æ¯”åº¦é«˜
        marker=dict(size=12, symbol='diamond')
    ))
    
    # Confidence interval
    fig.add_trace(go.Scatter(
        x=predictions_df['Year'].tolist() + predictions_df['Year'].tolist()[::-1],
        y=predictions_df['Upper_CI'].tolist() + predictions_df['Lower_CI'].tolist()[::-1],
        fill='toself',
        fillcolor='rgba(255, 0, 127, 0.15)', # åŠé€æ˜ç²‰è‰²
        line=dict(color='rgba(255,255,255,0)'),
        name='95% Confidence Interval',
        showlegend=True
    ))
    
    fig.update_layout(
        title=dict(
            text=f'<b>{reit_name} - Net Property Income Forecast</b>',
            x=0.5,
            xanchor='center',
            font=dict(size=20, color='white')
        ),
        xaxis=dict(
            title='Year', 
            showgrid=True, 
            gridcolor='rgba(255,255,255,0.1)' # æ·¡æ·¡çš„ç™½è‰²ç½‘æ ¼
        ),
        yaxis=dict(
            title="Net Property Income (RM '000)", 
            showgrid=True, 
            gridcolor='rgba(255,255,255,0.1)'
        ),
        height=500,
        hovermode='x unified',
        template='plotly_dark',  # å…³é”®ï¼šä½¿ç”¨æ·±è‰²æ¨¡æ¿
        paper_bgcolor='rgba(0,0,0,0)', # å…³é”®ï¼šèƒŒæ™¯å®Œå…¨é€æ˜
        plot_bgcolor='rgba(0,0,0,0)',  # å…³é”®ï¼šç»˜å›¾åŒºå®Œå…¨é€æ˜
        font=dict(size=12, color='white'),
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )
    
    return fig

def create_metrics_dashboard(df, predictions_df, metrics):
    """Create FIXED metrics dashboard with DARK THEME formatting"""
    
    fig = make_subplots(
        rows=2, cols=3,
        subplot_titles=(
            '<b>Next Year Forecast</b>',
            '<b>Growth Rate Trend</b>',
            '<b>Model Accuracy</b>',
            '<b>Occupancy Rate</b>',
            '<b>NPI Margin</b>',
            '<b>Revenue Growth</b>'
        ),
        specs=[
            [{"type": "indicator"}, {"type": "bar"}, {"type": "indicator"}],
            [{"type": "scatter"}, {"type": "scatter"}, {"type": "scatter"}]
        ],
        vertical_spacing=0.15,
        horizontal_spacing=0.12
    )
    
    # 1. FIXED: Next Year Forecast
    current_npi = df['Net_Property_Income'].iloc[-1]
    next_year_npi = predictions_df['Predicted_NPI'].iloc[0]
    
    fig.add_trace(go.Indicator(
        mode="number+delta",
        value=next_year_npi,
        delta={
            'reference': current_npi,
            'relative': True,
            'valueformat': '.1%',
            'increasing': {'color': '#00ff00'},
            'decreasing': {'color': '#ff4444'}  
        },
        title={
            'text': f"<b>Next Year Forecast</b><br><span style='font-size:0.8em; color:gray'>Current: RM {current_npi:,.0f}k</span>",
            'font': {'size': 14}
        },
        number={'valueformat': ',.0f', 'suffix': 'k', 'prefix': 'RM ', 'font': {'color': 'white'}},
    ), row=1, col=1)
    
    # 2. Growth bars
    colors = ['#00d2ff' if x >= 0 else '#ff4444' for x in predictions_df['Growth_Rate']]
    fig.add_trace(go.Bar(
        x=predictions_df['Year'],
        y=predictions_df['Growth_Rate'],
        name='Annual Growth',
        marker_color=colors,
        text=predictions_df['Growth_Rate'].round(1),
        texttemplate='%{text:.1f}%',
        textposition='outside',
        textfont=dict(color='white')
    ), row=1, col=2)
    
    # 3. Model accuracy
    fig.add_trace(go.Indicator(
        mode="gauge+number",
        value=metrics['RÂ²'],
        title={'text': "<b>Model RÂ² Score</b>", 'font': {'size': 14, 'color': 'white'}},
        number={'valueformat': '.3f', 'font': {'color': 'white'}},
        gauge={
            'axis': {'range': [0, 1], 'tickcolor': 'white'},
            'bar': {'color': "#00ff00"}, 
            'bgcolor': "rgba(255,255,255,0.1)",
            'bordercolor': "white",
            'steps': [
                {'range': [0, 0.7], 'color': "rgba(255,255,255,0.1)"},
                {'range': [0.7, 0.85], 'color': "rgba(255,255,0,0.3)"},
                {'range': [0.85, 1], 'color': "rgba(0,255,0,0.3)"}
            ],
            'threshold': {
                'line': {'color': "red", 'width': 2},
                'thickness': 0.75,
                'value': 0.85
            }
        }
    ), row=1, col=3)
    
    # 4-6. Time series with bright colors
    for i, (col, title, color, row_n, col_n) in enumerate([
        ('Occupancy_Rate', 'Occupancy %', '#00ff00', 2, 1), 
        ('NPI_Margin', 'NPI Margin %', '#e040fb', 2, 2),    
        ('Revenue_Growth', 'Revenue Growth %', '#ff9100', 2, 3) 
    ]):
        fig.add_trace(go.Scatter(
            x=df['Year'],
            y=df[col],
            mode='lines+markers',
            name=title,
            line=dict(color=color, width=2),
            marker=dict(size=8)
        ), row=row_n, col=col_n)
    
    fig.update_layout(
        height=700,
        showlegend=False,
        title_text="<b>ğŸ“Š Comprehensive Performance Dashboard</b>",
        title_x=0.5,
        title_font=dict(size=20, color='white'),
        template='plotly_dark',   
        paper_bgcolor='rgba(0,0,0,0)', 
        plot_bgcolor='rgba(0,0,0,0)',  
        font=dict(color='white')
    )
    
    # Update axis grids to be subtle
    fig.update_xaxes(showgrid=True, gridcolor='rgba(255,255,255,0.1)')
    fig.update_yaxes(showgrid=True, gridcolor='rgba(255,255,255,0.1)')
    
    # Specific y-axis labels
    fig.update_yaxes(title_text="Growth %", row=1, col=2)
    fig.update_yaxes(title_text="%", row=2, col=1)
    fig.update_yaxes(title_text="%", row=2, col=2)
    fig.update_yaxes(title_text="%", row=2, col=3)
    
    return fig

def create_comparison_chart(all_predictions):
    """Multi-REIT comparison with DARK THEME"""
    
    fig = go.Figure()
    
    colors = ['#00d2ff', '#ff007f', '#ff9100'] # è“ï¼Œç²‰ï¼Œæ©™ (é«˜äº®è‰²)
    
    for i, (reit_name, pred_df) in enumerate(all_predictions.items()):
        fig.add_trace(go.Scatter(
            x=pred_df['Year'],
            y=pred_df['Predicted_NPI'],
            mode='lines+markers',
            name=reit_name,
            line=dict(color=colors[i % len(colors)], width=3),
            marker=dict(size=10)
        ))
    
    fig.update_layout(
        title=dict(
            text='<b>ğŸ† Multi-REIT Performance Comparison</b>',
            font=dict(color='white', size=18)
        ),
        xaxis_title='Year',
        yaxis_title="Net Property Income (RM '000)",
        height=500,
        hovermode='x unified',
        template='plotly_dark',   
        paper_bgcolor='rgba(0,0,0,0)', 
        plot_bgcolor='rgba(0,0,0,0)',  
        font=dict(size=12, color='white'),
        legend=dict(font=dict(color='white'))
    )
    
    fig.update_xaxes(gridcolor='rgba(255,255,255,0.1)')
    fig.update_yaxes(gridcolor='rgba(255,255,255,0.1)')
    
    return fig

# ============================================================================
# 5. MAIN PREDICTION FUNCTIONS
# ============================================================================

def predict_single_reit(reit_name, years_ahead, interest_rate, occupancy_change, revenue_growth):
    """Main prediction function"""
    
    all_reits = load_all_reit_data()
    df = all_reits[reit_name]
    
    # Train model
    model, feature_cols, metrics, feature_importance = train_simple_model(df)
    
    # Generate predictions
    predictions_df = predict_hybrid(
        df, model, feature_cols,
        years_ahead=years_ahead,
        interest_rate_change=interest_rate,
        occupancy_change=occupancy_change,
        revenue_growth_rate=revenue_growth if revenue_growth > 0 else None
    )
    
    # Add investment recommendation based on growth rate
    def get_recommendation(growth_rate):
        if growth_rate >= 8:
            return "ğŸŸ¢ BUY"
        elif growth_rate >= 4:
            return "ğŸŸ¡ HOLD"
        else:
            return "ğŸ”´ SELL"
    
    predictions_df['Recommendation'] = predictions_df['Growth_Rate'].apply(get_recommendation)
    
    # Create visualizations
    pred_chart = create_prediction_chart(df, predictions_df, reit_name)
    metrics_dashboard = create_metrics_dashboard(df, predictions_df, metrics)
    
    # Summary
    current_npi = df['Net_Property_Income'].iloc[-1]
    next_year_npi = predictions_df['Predicted_NPI'].iloc[0]
    growth = ((next_year_npi - current_npi) / current_npi) * 100
    
    summary = f"""
## ğŸ“Š {reit_name} - Prediction Summary

### ğŸ¯ Key Metrics
- **Current NPI (2024):** RM {current_npi:,.0f}k
- **Next Year Forecast (2025):** RM {next_year_npi:,.0f}k
- **Expected Growth:** {growth:+.2f}%
- **Model Accuracy (RÂ²):** {metrics['RÂ²']:.3f}
- **Prediction Method:** Hybrid ML + Time Series

### ğŸ“ˆ Future Projections
"""
    
    for _, row in predictions_df.iterrows():
        summary += f"\n- **{int(row['Year'])}:** RM {row['Predicted_NPI']:,.0f}k ({row['Growth_Rate']:+.2f}% growth, {row['Confidence']:.0%} confidence) - {row['Recommendation']}"
    
    # Format table with recommendation
    pred_table = predictions_df[['Year', 'Predicted_NPI', 'Lower_CI', 'Upper_CI', 'Growth_Rate', 'Recommendation']].copy()
    pred_table.columns = ['Year', 'Predicted NPI (RM k)', 'Lower Bound', 'Upper Bound', 'Growth %', 'Recommendation']
    for col in ['Predicted NPI (RM k)', 'Lower Bound', 'Upper Bound']:
        pred_table[col] = pred_table[col].round(0).astype(int)
    pred_table['Growth %'] = pred_table['Growth %'].round(2)
    
    return pred_chart, metrics_dashboard, summary, pred_table

def compare_multiple_reits(selected_reits, years_ahead):
    """Compare multiple REITs"""
    
    all_reits = load_all_reit_data()
    all_predictions = {}
    
    for reit_name in selected_reits:
        df = all_reits[reit_name]
        model, feature_cols, _, _ = train_simple_model(df)
        predictions_df = predict_hybrid(df, model, feature_cols, years_ahead=years_ahead)
        
        # Add recommendations
        def get_recommendation(growth_rate):
            if growth_rate >= 8:
                return "ğŸŸ¢ BUY"
            elif growth_rate >= 4:
                return "ğŸŸ¡ HOLD"
            else:
                return "ğŸ”´ SELL"
        
        predictions_df['Recommendation'] = predictions_df['Growth_Rate'].apply(get_recommendation)
        all_predictions[reit_name] = predictions_df
    
    comparison_chart = create_comparison_chart(all_predictions)
    
    # Table with recommendations
    comparison_data = []
    for reit_name, pred_df in all_predictions.items():
        for _, row in pred_df.iterrows():
            comparison_data.append({
                'REIT': reit_name,
                'Year': int(row['Year']),
                'Predicted NPI': f"{row['Predicted_NPI']:,.0f}",
                'Growth Rate': f"{row['Growth_Rate']:+.2f}%",
                'Recommendation': row['Recommendation']
            })
    
    comparison_table = pd.DataFrame(comparison_data)
    
    # Summary
    summary = f"## ğŸ† Comparison of {len(selected_reits)} REITs\n\n"
    for reit_name, pred_df in all_predictions.items():
        avg_growth = pred_df['Growth_Rate'].mean()
        final_npi = pred_df['Predicted_NPI'].iloc[-1]
        final_rec = pred_df['Recommendation'].iloc[0]
        summary += f"**{reit_name}:** {final_rec}\n"
        summary += f"- Average Annual Growth: {avg_growth:.2f}%\n"
        summary += f"- Final NPI ({int(pred_df['Year'].iloc[-1])}): RM {final_npi:,.0f}k\n\n"
    
    return comparison_chart, comparison_table, summary

# ============================================================================
# 6. GRADIO INTERFACE
# ============================================================================

custom_css = """
<style>
    /* -----------------------------------------------------------
       ä¿®å¤é€»è¾‘ï¼šå°†â€œè½¨é“é¢œè‰²â€å’Œâ€œè¿›åº¦æ¡é¢œè‰²â€åˆ†å±‚å¤„ç†
       ----------------------------------------------------------- */

    /* Layer 1: è¾“å…¥æ¡†æœ¬ä½“è®¾ä¸ºé€æ˜ */
    /* è¿™æ · Gradio çš„ JavaScript å¯ä»¥è‡ªç”±ç»˜åˆ¶æ©™è‰²è¿›åº¦æ¡ï¼Œä¸å—å¹²æ‰° */
    input[type=range] {
        background-color: transparent !important; 
    }

    /* Layer 2: é’ˆå¯¹ Chrome/Edge/Safari çš„è½¨é“ (Track) å•ç‹¬ä¸Šè‰² */
    /* è¿™æ˜¯åº•è‰²ï¼Œæ°¸è¿œæ˜¾ç¤ºä¸ºç°è‰²ï¼Œä¸ä¼šè¢« Reset æŒ‰é’®å¼„ä¹± */
    input[type=range]::-webkit-slider-runnable-track {
        background-color: #4b5563 !important; /* æ·±ç°è‰²è½¨é“ */
        height: 6px;
        border-radius: 3px;
    }

    /* Layer 2: é’ˆå¯¹ Firefox çš„è½¨é“å•ç‹¬ä¸Šè‰² */
    input[type=range]::-moz-range-track {
        background-color: #4b5563 !important;
        height: 6px;
        border-radius: 3px;
    }

    /* -----------------------------------------------------------
       å…¶ä»–ç¾åŒ–æ ·å¼
       ----------------------------------------------------------- */

    /* è®©æ»‘å—çš„åœ†ç‚¹ï¼ˆæŠŠæ‰‹ï¼‰æ›´æ˜æ˜¾ã€å¥½æŠ“ */
    input[type=range]::-webkit-slider-thumb {
        height: 16px !important;
        width: 16px !important;
        background: #ffffff !important;
        border: 2px solid #2E86AB !important; /* åŠ ä¸ªè“è‰²è¾¹æ¡† */
        box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        margin-top: -5px !important; /* å‚ç›´å±…ä¸­ä¿®æ­£ */
    }

    /* å…è´£å£°æ˜æ ·å¼ (ä¿æŒä¸å˜) */
    .disclaimer-box { background-color: #fff3cd; padding: 20px; border-radius: 5px; border-left: 5px solid #ff9800; margin: 20px 0; }
    .disclaimer-box p { color: #2d3436 !important; line-height: 1.6 !important; margin-bottom: 10px !important; display: block !important; }
    .disclaimer-box strong { color: #c0392b !important; font-weight: bold !important; }
    .disclaimer-box h3 { color: #d63031 !important; margin-top: 0 !important; }
    .footer-note { text-align: center; color: #0066cc !important; font-size: 0.9em; margin-top: 15px !important; }
</style>
"""

# 2. åˆå§‹åŒ– App
with gr.Blocks(title="REIT Smart Board") as app:
    
    # 3. æ³¨å…¥ CSS
    gr.HTML(custom_css)
    
    gr.Markdown("""
    # ğŸ¢ REIT Smart Analytics Board
    ### Hybrid ML + Time Series Forecasting System
    **XGBoost Model with Trend Analysis | FYP Project 2025**
    """)
    
    with gr.Tabs():
        
        # TAB 1: Single REIT
        with gr.Tab("ğŸ¯ Single REIT Prediction"):
            gr.Markdown("### Analyze individual REIT performance with advanced forecasting")
            
            with gr.Row():
                with gr.Column(scale=1):
                    reit_dropdown = gr.Dropdown(
                        choices=['Pavilion REIT', 'Sunway REIT', 'IGB REIT'],
                        value='Pavilion REIT',
                        label="ğŸ“‹ Select REIT",
                        info="Choose which REIT to analyze"
                    )
                    
                    years_slider = gr.Slider(
                        minimum=1, maximum=5, value=3, step=1,
                        label="ğŸ“… Prediction Horizon (Years)",
                        info="Number of years to forecast"
                    )
                    
                    gr.Markdown("#### ğŸ² Economic Scenario Simulation")
                    
                    interest_rate_slider = gr.Slider(
                        minimum=-2, maximum=2, value=0, step=0.25,
                        label="ğŸ’° Interest Rate Change (%)",
                        info="Simulate impact of rate changes",
                        interactive=True,
                        elem_classes="custom-slider"
                    )
                    
                    occupancy_slider = gr.Slider(
                        minimum=-10, maximum=10, value=0, step=1,
                        label="ğŸ—ï¸ Occupancy Rate Adjustment (%)",
                        info="Modify occupancy assumptions",
                        interactive=True,
                        elem_classes="custom-slider"
                    )
                    
                    revenue_growth_slider = gr.Slider(
                        minimum=0, maximum=30, value=0, step=1,
                        label="ğŸ“ˆ Custom Revenue Growth (%) - 0 for auto",
                        info="Override automatic growth calculation",
                        interactive=True,
                        elem_classes="custom-slider"
                    )
                    
                    predict_btn = gr.Button("ğŸš€ Generate Forecast", variant="primary", size="lg")
                
                with gr.Column(scale=2):
                    summary_output = gr.Markdown()
                    pred_chart_output = gr.Plot(label="Prediction Chart")
            
            with gr.Row():
                metrics_dashboard_output = gr.Plot(label="Performance Dashboard")
            
            with gr.Row():
                pred_table_output = gr.Dataframe(label="Detailed Predictions")
            
            predict_btn.click(
                fn=predict_single_reit,
                inputs=[reit_dropdown, years_slider, interest_rate_slider,
                       occupancy_slider, revenue_growth_slider],
                outputs=[pred_chart_output, metrics_dashboard_output,
                        summary_output, pred_table_output]
            )
        
        # TAB 2: Multi-REIT Comparison
        with gr.Tab("ğŸ“Š Multi-REIT Comparison"):
            gr.Markdown("### Compare performance across multiple REITs")
            
            with gr.Row():
                with gr.Column(scale=1):
                    reit_checkboxes = gr.CheckboxGroup(
                        choices=['Pavilion REIT', 'Sunway REIT', 'IGB REIT'],
                        value=['Pavilion REIT', 'Sunway REIT'],
                        label="ğŸ“‹ Select REITs to Compare",
                        info="Choose 2 or more REITs"
                    )
                    
                    compare_years_slider = gr.Slider(
                        minimum=1, maximum=5, value=3, step=1,
                        label="ğŸ“… Prediction Years"
                    )
                    
                    compare_btn = gr.Button("ğŸ† Compare REITs", variant="primary", size="lg")
                
                with gr.Column(scale=2):
                    comparison_summary = gr.Markdown()
                    comparison_chart_output = gr.Plot(label="Comparison Chart")
            
            with gr.Row():
                comparison_table_output = gr.Dataframe(label="Comparison Table")
            
            compare_btn.click(
                fn=compare_multiple_reits,
                inputs=[reit_checkboxes, compare_years_slider],
                outputs=[comparison_chart_output, comparison_table_output, comparison_summary]
            )
        
        # TAB 3: About
        with gr.Tab("â„¹ï¸ About & Documentation"):
            gr.Markdown("""
            ## ğŸ“š REIT Smart Analytics Board
            
            ### ğŸ¯ Project Overview
            Professional REIT performance prediction system using hybrid machine learning approach.
            
            ### ğŸ”§ Technical Implementation
            - **Primary Model:** XGBoost Regression (simplified, regularized)
            - **Prediction Method:** Hybrid (70% ML + 30% Time Series Trend)
            - **Key Features:** Revenue, Occupancy Rate, NPI Margin, Investment Properties
            - **Validation:** RÂ² Score, MAE, RMSE metrics
            
            ### âœ¨ Key Features
            1. **Single REIT Analysis** - Deep dive with scenario simulation
            2. **Multi-REIT Comparison** - Side-by-side performance analysis
            3. **Economic Scenarios** - Interest rate and occupancy impact
            4. **Confidence Intervals** - Statistical uncertainty quantification
            5. **Interactive Visualizations** - Plotly-powered charts
            
            ### ğŸ“Š Prediction Methodology
            
            **Hybrid Approach:**
            - ML Model (70%): Learns from historical relationships
            - Trend Component (30%): Ensures realistic growth patterns
            - Regularization: Prevents overfitting on small dataset
            
            **Why Hybrid?**
            - Small dataset (5 years) â†’ pure ML can overfit
            - Trend component ensures growth variation
            - Weighted combination provides stability
            
            ### ğŸ“– How to Use
            
            **Single REIT Analysis:**
            1. Select desired REIT from dropdown
            2. Set prediction horizon (1-5 years)
            3. Adjust economic scenarios (optional)
            4. Click "Generate Forecast"
            5. Review charts, metrics, and detailed predictions
            
            **Multi-REIT Comparison:**
            1. Select 2 or 3 REITs to compare
            2. Set prediction years
            3. Click "Compare REITs"
            4. Analyze relative performance
            
            **Scenario Simulation:**
            - **Interest Rate:** +1% typically reduces growth by ~0.3%
            - **Occupancy:** +5% can improve NPI by 2-3%
            - **Custom Growth:** Override automatic calculations
            
            ### ğŸ“ FYP Information
            - **Course:** Bachelor of Software Engineering
            - **Supervisor:** Ms. Chan Ler Kuan
            - **Technology Stack:** Python, XGBoost, Gradio, Plotly
            
            ### ğŸ“ˆ Model Performance
            - **Training Data:** 2020-2024 (5 years)
            - **Features Used:** 5 core financial metrics
            - **Model Type:** Regularized XGBoost + Trend Analysis
            - **Accuracy:** RÂ² typically > 0.85
            
            ### âš ï¸ Important Notes
            
            **Limitations:**
            - Predictions based on historical patterns
            - Cannot predict black swan events
            - Best used for 1-3 year forecasts
            - Uncertainty increases with time horizon
            
            **Assumptions:**
            - Stable economic conditions
            - No major portfolio restructuring
            - Historical relationships persist
            - Market efficiency
            
            ### ğŸ” Understanding the Results
            
            **Predicted NPI:** Main forecast value
            **Growth Rate:** Year-over-year percentage change
            **Confidence Interval:** Statistical range (95% probability)
            **Confidence Score:** Model certainty (decreases over time)
            
            ### ğŸ’¡ Investment Insights
            
            Use this tool to:
            - Compare REIT performance trajectories
            - Test economic scenario impacts
            - Identify growth trends
            - Support investment decisions
            - Risk assessment
            
            ### ğŸ“§ Support & Feedback
            For questions, issues, or feedback:
            - Email: b2300042a@sc.edu.my
            - GitHub: [repository link]
            
            ### ğŸ™ Acknowledgments
            - Data Source: Public REIT financial reports
            - Tools: Python, Scikit-learn, XGBoost, Gradio, Plotly
            - Supervisor guidance and support
            
            ---
            **Version:** 2.0 (Fixed Prediction Variation Issue)  
            **Last Updated:** December 2025  
            **Status:** Production Ready for FYP Submission
            """)
    
    # Disclaimer section with styled box
    gr.Markdown("---")
    gr.HTML("""
    <style>
        /* å®šä¹‰å…è´£å£°æ˜ä¸“ç”¨æ ·å¼ï¼Œé˜²æ­¢è¢«å…¨å±€æ ·å¼æ±¡æŸ“ */
        .disclaimer-box {
            background-color: #fff3cd;
            border-left: 5px solid #ff9800;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            font-family: sans-serif;
        }
        /* å¼ºåˆ¶æ‰€æœ‰æ–‡å­—æ®µè½ä¸ºæ·±è‰²ï¼Œå¹¶å¼ºåˆ¶æ¢è¡Œ */
        .disclaimer-box p {
            color: #2d3436 !important;
            line-height: 1.6 !important;
            margin-bottom: 15px !important;
            display: block !important; /* ç¡®ä¿æ®µè½æ˜¯ä»ä¸Šåˆ°ä¸‹æ’åˆ— */
        }
        /* âš ï¸ å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶åŠ ç²—æ–‡å­—æ˜¾ç¤ºä¸ºæ·±çº¢è‰²ï¼Œç¡®ä¿ä¸ä¼šéšèº« */
        .disclaimer-box strong {
            color: #c0392b !important; 
            font-weight: bold !important;
            display: inline !important; /* ç¡®ä¿åŠ ç²—æ–‡å­—åœ¨å¥å­ä¸­é—´ï¼Œä¸æ¢è¡Œ */
        }
        /* æ ‡é¢˜æ ·å¼ */
        .disclaimer-box h3 {
            color: #d63031 !important;
            margin-top: 0 !important;
            margin-bottom: 10px !important;
            font-weight: bold;
        }
        /* åº•éƒ¨å°å­—æ ·å¼ */
        .footer-note {
            text-align: center;
            color: #0066cc !important;
            font-weight: bold;
            font-size: 0.9em;
        }
    </style>

    <div class="disclaimer-box">
        <h3>âš ï¸ Important Disclaimer</h3>
        
        <p>
            This REIT recommendation system is developed for <strong>academic and research purposes only</strong>. 
            The information and outputs provided are for general informational use and 
            <strong>do not constitute financial, investment, or legal advice</strong>.
        </p>
        
        <p>
            <strong>No guarantee</strong> is made regarding the accuracy, completeness, or reliability of the recommendations. 
            Users are <strong>solely responsible</strong> for any investment decisions they make based on this system's outputs.
        </p>
        
        <p>
            âš¡ <strong>Always consult a licensed financial advisor</strong> before making investment choices. 
            The developers disclaim any liability for losses or damages arising from the use of this system.
        </p>
        
        <hr style='border: none; border-top: 1px solid #dcdcdc; margin: 15px 0;'>
        
        <p class="footer-note">
            ğŸ“§ For Academic Inquiries Only | Not for Commercial Investment Advice
        </p>
    </div>
    """)
    
# ============================================================================
# 7. LAUNCH APPLICATION
# ============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("ğŸš€ STARTING REIT SMART BOARD - FIXED VERSION")
    print("=" * 70)
    print("âœ… Hybrid prediction method active")
    print("âœ… UI improvements applied")
    print("âœ… All 3 REITs loaded")
    print("=" * 70)
    
    # Try multiple ports to find an available one
    import socket
    
    def find_free_port():
        """Find a free port automatically"""
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind(('', 0))
            s.listen(1)
            port = s.getsockname()[1]
        return port
    
    port = find_free_port()
    print(f"ğŸŒ Using port: {port}")
    print("=" * 70)
    
    app.launch(
        share=False,
        inbrowser=True,
        server_port=port,
        show_error=True
    )
    
    print(f"\nâœ… Application running successfully!")
    print(f"ğŸ“ Access at: http://localhost:{port}")
    print("â¹ï¸  Press Ctrl+C to stop\n")
